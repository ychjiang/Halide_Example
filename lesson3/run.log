Realizing Pipeline for target(arch_unknown-0-os_unknown)
jit-compiling for: target(x86-64-linux-avx-f16c-jit-sse41)
Inferred argument: (void *) __user_context
Creating initial loop nests...
Injecting realization of { gradient }
for (.__root, 0, 1) {
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    let gradient.s0.__outermost.loop_extent = 1
    let gradient.s0.__outermost.loop_max = 0
    let gradient.s0.__outermost.loop_min = 0
    for (gradient.s0.__outermost, gradient.s0.__outermost.loop_min, gradient.s0.__outermost.loop_extent) {
      for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
        for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
          gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
        }
      }
    }
  }
}

Lowering after creating initial loop nests:
produce gradient {
  let gradient.s0.y.loop_max = gradient.s0.y.max
  let gradient.s0.y.loop_min = gradient.s0.y.min
  let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
  let gradient.s0.x.loop_max = gradient.s0.x.max
  let gradient.s0.x.loop_min = gradient.s0.x.min
  let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
  for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
    for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
      gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
    }
  }
}

Skipping injecting memoization...
Injecting tracing...
Lowering after injecting tracing:
produce gradient {
  let gradient.s0.y.loop_max = gradient.s0.y.max
  let gradient.s0.y.loop_min = gradient.s0.y.min
  let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
  let gradient.s0.x.loop_max = gradient.s0.x.max
  let gradient.s0.x.loop_min = gradient.s0.x.min
  let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
  for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
    for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
      gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
    }
  }
}

Adding checks for parameters
Lowering after injecting parameter checks:
produce gradient {
  let gradient.s0.y.loop_max = gradient.s0.y.max
  let gradient.s0.y.loop_min = gradient.s0.y.min
  let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
  let gradient.s0.x.loop_max = gradient.s0.x.max
  let gradient.s0.x.loop_min = gradient.s0.x.min
  let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
  for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
    for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
      gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
    }
  }
}

Computing bounds of each function's value
Bounds on value 0 for func gradient are: neg_inf, pos_inf
Adding checks for images
Injecting constraints for gradient.0
Injecting constraints for gradient.1
Lowering after injecting image checks:
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Performing computation bounds inference...
Lowering after computation bounds inference:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Removing extern loops...
Lowering after removing extern loops:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Performing sliding window optimization...
Lowering after sliding window:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Performing allocation bounds inference...
Lowering after allocation bounds inference:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Removing code that depends on undef values...
Lowering after removing code that depends on undef values:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Uniquifying variable names...
Lowering after uniquifying variable names:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Simplifying...
Lowering after first simplification:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
    let gradient.s0.y.loop_min = gradient.min.1
    let gradient.s0.y.loop_extent = gradient.extent.1
    let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
    let gradient.s0.x.loop_min = gradient.min.0
    let gradient.s0.x.loop_extent = gradient.extent.0
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Performing storage folding optimization...
Lowering after storage folding:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
    let gradient.s0.y.loop_min = gradient.min.1
    let gradient.s0.y.loop_extent = gradient.extent.1
    let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
    let gradient.s0.x.loop_min = gradient.min.0
    let gradient.s0.x.loop_extent = gradient.extent.0
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Injecting debug_to_file calls...
Lowering after injecting debug_to_file calls:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
    let gradient.s0.y.loop_min = gradient.min.1
    let gradient.s0.y.loop_extent = gradient.extent.1
    let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
    let gradient.s0.x.loop_min = gradient.min.0
    let gradient.s0.x.loop_extent = gradient.extent.0
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Injecting prefetches...
Lowering after injecting prefetches:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
    let gradient.s0.y.loop_min = gradient.min.1
    let gradient.s0.y.loop_extent = gradient.extent.1
    let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
    let gradient.s0.x.loop_min = gradient.min.0
    let gradient.s0.x.loop_extent = gradient.extent.0
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Dynamically skipping stages...
Lowering after dynamically skipping stages:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
    let gradient.s0.y.loop_min = gradient.min.1
    let gradient.s0.y.loop_extent = gradient.extent.1
    let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
    let gradient.s0.x.loop_min = gradient.min.0
    let gradient.s0.x.loop_extent = gradient.extent.0
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Forking asynchronous producers...
Lowering after forking asynchronous producers:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
  let gradient.s0.y.loop_min = gradient.min.1
  let gradient.s0.y.loop_extent = gradient.extent.1
  let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
  let gradient.s0.x.loop_min = gradient.min.0
  let gradient.s0.x.loop_extent = gradient.extent.0
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Destructuring tuple-valued realizations...
Lowering after destructuring tuple-valued realizations:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
  let gradient.s0.y.loop_min = gradient.min.1
  let gradient.s0.y.loop_extent = gradient.extent.1
  let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
  let gradient.s0.x.loop_min = gradient.min.0
  let gradient.s0.x.loop_extent = gradient.extent.0
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Canonicalizing GPU var names...
Lowering after canonicalizing GPU var names:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
  let gradient.s0.y.loop_min = gradient.min.1
  let gradient.s0.y.loop_extent = gradient.extent.1
  let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
  let gradient.s0.x.loop_min = gradient.min.0
  let gradient.s0.x.loop_extent = gradient.extent.0
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Performing storage flattening...
Lowering after storage flattening:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
  let gradient.s0.y.loop_min = gradient.min.1
  let gradient.s0.y.loop_extent = gradient.extent.1
  let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
  let gradient.s0.x.loop_min = gradient.min.0
  let gradient.s0.x.loop_extent = gradient.extent.0
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((0 + (gradient.s0.x*gradient.stride.0)) + (gradient.s0.y*gradient.stride.1)) - ((0 + (gradient.min.0*gradient.stride.0)) + (gradient.min.1*gradient.stride.1)))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Unpacking buffer arguments...
Lowering after unpacking buffer arguments...
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
  let gradient.s0.y.loop_min = gradient.min.1
  let gradient.s0.y.loop_extent = gradient.extent.1
  let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
  let gradient.s0.x.loop_min = gradient.min.0
  let gradient.s0.x.loop_extent = gradient.extent.0
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((0 + (gradient.s0.x*gradient.stride.0)) + (gradient.s0.y*gradient.stride.1)) - ((0 + (gradient.min.0*gradient.stride.0)) + (gradient.min.1*gradient.stride.1)))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Skipping rewriting memoized allocations...
Simplifying...
Lowering after second simplifcation:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Reduce prefetch dimension...
Lowering after reduce prefetch dimension:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Unrolling...
Lowering after unrolling:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Vectorizing...
Lowering after vectorizing:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Detecting vector interleavings...
Lowering after rewriting vector interleavings:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Partitioning loops to simplify boundary conditions...
Lowering after partitioning loops:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Trimming loops to the region over which they do something...
Lowering after loop trimming:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Injecting early frees...
Lowering after injecting early frees:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Bounding small allocations...
Lowering after bounding small allocations:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Simplifying...
Lowering unsafe promises...
Lowering after lowering unsafe promises:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Lowering after final simplification:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let t1 = ((gradient.min.1*gradient.stride.1) + gradient.min.0)
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      let t2 = ((gradient.s0.y*gradient.stride.1) - t1)
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(gradient.s0.x + t2)] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Skipping Hexagon offload...
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function gradient...
Generating llvm bitcode for function gradient...
0x1ba4200
Done generating llvm bitcode
Adding module pass: Target Transform Information
Adding function pass: Target Transform Information
Adding function pass: Instrument function entry/exit with calls to e.g. mcount() (pre inlining)
Adding function pass: Type-Based Alias Analysis
Adding function pass: Scoped NoAlias Alias Analysis
Adding function pass: Simplify the CFG
Adding function pass: SROA
Adding function pass: Early CSE
Adding function pass: Lower 'expect' Intrinsics
Adding module pass: Force set function attributes
Adding module pass: Type-Based Alias Analysis
Adding module pass: Scoped NoAlias Alias Analysis
Adding module pass: Infer set function attributes
Adding module pass: Call-site splitting
Adding module pass: Interprocedural Sparse Conditional Constant Propagation
Adding module pass: Called Value Propagation
Adding module pass: Global Variable Optimizer
Adding module pass: Promote Memory to Register
Adding module pass: Dead Argument Elimination
Adding module pass: Combine redundant instructions
Adding module pass: Simplify the CFG
Adding module pass: Globals Alias Analysis
Adding module pass: Remove unused exception handling info
Adding module pass: Function Integration/Inlining
Adding module pass: Deduce function attributes
Adding module pass: Promote 'by reference' arguments to scalars
Adding module pass: SROA
Adding module pass: Early CSE w/ MemorySSA
Adding module pass: Speculatively execute instructions if target has divergent branches
Adding module pass: Jump Threading
Adding module pass: Value Propagation
Adding module pass: Simplify the CFG
Adding module pass: Combine redundant instructions
Adding module pass: Conditionally eliminate dead library calls
Adding module pass: PGOMemOPSize
Adding module pass: Tail Call Elimination
Adding module pass: Simplify the CFG
Adding module pass: Reassociate expressions
Adding module pass: Rotate Loops
Adding module pass: Loop Invariant Code Motion
Adding module pass: Unswitch loops
Adding module pass: Simplify the CFG
Adding module pass: Combine redundant instructions
Adding module pass: Induction Variable Simplification
Adding module pass: Recognize loop idioms
Adding module pass: Delete dead loops
Adding module pass: Unroll loops
Adding module pass: MergedLoadStoreMotion
Adding module pass: Global Value Numbering
Adding module pass: MemCpy Optimization
Adding module pass: Sparse Conditional Constant Propagation
Adding module pass: Bit-Tracking Dead Code Elimination
Adding module pass: Combine redundant instructions
Adding module pass: Jump Threading
Adding module pass: Value Propagation
Adding module pass: Dead Store Elimination
Adding module pass: Loop Invariant Code Motion
Adding module pass: Aggressive Dead Code Elimination
Adding module pass: Simplify the CFG
Adding module pass: Combine redundant instructions
Adding module pass: A No-Op Barrier Pass
Adding module pass: Eliminate Available Externally Globals
Adding module pass: Deduce function attributes in RPO
Adding module pass: Global Variable Optimizer
Adding module pass: Dead Global Elimination
Adding module pass: Globals Alias Analysis
Adding module pass: Float to int
Adding module pass: Rotate Loops
Adding module pass: Loop Distribution
Adding module pass: Loop Vectorization
Adding module pass: Loop Load Elimination
Adding module pass: Combine redundant instructions
Adding module pass: Simplify the CFG
Adding module pass: SLP Vectorizer
Adding module pass: Combine redundant instructions
Adding module pass: Unroll loops
Adding module pass: Combine redundant instructions
Adding module pass: Loop Invariant Code Motion
Adding module pass: Alignment from assumptions
Adding module pass: Strip Unused Function Prototypes
Adding module pass: Dead Global Elimination
Adding module pass: Merge Duplicate Global Constants
Adding module pass: Loop Sink
Adding module pass: Remove redundant instructions
Adding module pass: Hoist/decompose integer division and remainder
Adding module pass: Simplify the CFG
; ModuleID = 'gradient'
source_filename = "/home/caffe/Halide/Halide/src/runtime/buffer_t.cpp"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64--linux-gnu"

%struct.halide_filter_argument_t = type { i8*, i32, i32, %struct.halide_type_t, %struct.halide_scalar_value_t*, %struct.halide_scalar_value_t*, %struct.halide_scalar_value_t*, %struct.halide_scalar_value_t*, i64** }
%struct.halide_type_t = type { i8, i8, i16 }
%struct.halide_scalar_value_t = type { %union.anon }
%union.anon = type { double }
%struct.halide_filter_metadata_t = type { i32, i32, %struct.halide_filter_argument_t*, i8*, i8* }
%struct.halide_buffer_t = type { i64, %struct.halide_device_interface_t*, i8*, i64, %struct.halide_type_t, i32, %struct.halide_dimension_t*, i8* }
%struct.halide_device_interface_t = type { i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, void (i8*, %struct.halide_device_interface_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_device_interface_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, i32, i32, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, %struct.halide_buffer_t*, i64, %struct.halide_device_interface_t*)*, i32 (i8*, %struct.halide_buffer_t*)*, i32 (i8*, i32*, i32*)*, %struct.halide_device_interface_impl_t* }
%struct.halide_device_interface_impl_t = type opaque
%struct.halide_dimension_t = type { i32, i32, i32, i32 }

@str = private constant [9 x i8] c"gradient\00", align 32
@str.3 = private constant [23 x i8] c"Output buffer gradient\00", align 32
@str.4 = private constant [18 x i8] c"gradient.stride.0\00", align 32
@str.5 = private constant [2 x i8] c"1\00", align 32
@str.6 = private constant [15 x i8] c"__user_context\00", align 32
@0 = private constant [4 x i64*] zeroinitializer
@1 = private constant [2 x %struct.halide_filter_argument_t] [%struct.halide_filter_argument_t { i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str.6, i32 0, i32 0), i32 0, i32 0, %struct.halide_type_t { i8 3, i8 64, i16 1 }, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, i64** null }, %struct.halide_filter_argument_t { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str, i32 0, i32 0), i32 2, i32 2, %struct.halide_type_t { i8 0, i8 32, i16 1 }, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, %struct.halide_scalar_value_t* null, i64** getelementptr inbounds ([4 x i64*], [4 x i64*]* @0, i32 0, i32 0) }]
@str.7 = private constant [45 x i8] c"x86-64-linux-avx-f16c-jit-sse41-user_context\00", align 32
@gradient_metadata_storage = private constant %struct.halide_filter_metadata_t { i32 1, i32 2, %struct.halide_filter_argument_t* getelementptr inbounds ([2 x %struct.halide_filter_argument_t], [2 x %struct.halide_filter_argument_t]* @1, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @str.7, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str, i32 0, i32 0) }

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i32, i1) #0

declare i32 @halide_error_bad_dimensions(i8*, i8*, i32, i32) local_unnamed_addr #1

declare i32 @halide_error_bad_type(i8*, i8*, i8 zeroext, i8 zeroext, i8 zeroext, i8 zeroext, i16 zeroext, i16 zeroext) local_unnamed_addr #1

declare i32 @halide_error_buffer_allocation_too_large(i8*, i8*, i64, i64) local_unnamed_addr #1

declare i32 @halide_error_buffer_argument_is_null(i8*, i8*) local_unnamed_addr #1

declare i32 @halide_error_buffer_extents_negative(i8*, i8*, i32, i32) local_unnamed_addr #1

declare i32 @halide_error_buffer_extents_too_large(i8*, i8*, i64, i64) local_unnamed_addr #1

declare i32 @halide_error_constraint_violated(i8*, i8*, i32, i8*, i32) local_unnamed_addr #1

declare i32 @halide_error_host_is_null(i8*, i8*) local_unnamed_addr #1

; Function Attrs: nounwind
define i32 @gradient(i8* %__user_context, %struct.halide_buffer_t* noalias %gradient.buffer) local_unnamed_addr #2 {
entry:
  %0 = alloca [8 x i32], align 4
  %1 = icmp eq %struct.halide_buffer_t* %gradient.buffer, null
  br i1 %1, label %"assert failed", label %"assert succeeded", !prof !6

"assert failed":                                  ; preds = %entry
  %2 = tail call i32 @halide_error_buffer_argument_is_null(i8* %__user_context, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str, i64 0, i64 0)) #3
  br label %destructor_block

"assert succeeded":                               ; preds = %entry
  %host.i = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %gradient.buffer, i64 0, i32 2
  %3 = load i8*, i8** %host.i, align 8, !tbaa !7
  %code.i42 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %gradient.buffer, i64 0, i32 4, i32 0
  %4 = load i8, i8* %code.i42, align 8, !tbaa !16
  %bits.i41 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %gradient.buffer, i64 0, i32 4, i32 1
  %5 = load i8, i8* %bits.i41, align 1, !tbaa !17
  %lanes.i40 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %gradient.buffer, i64 0, i32 4, i32 2
  %6 = load i16, i16* %lanes.i40, align 2, !tbaa !18
  %dimensions.i = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %gradient.buffer, i64 0, i32 5
  %7 = load i32, i32* %dimensions.i, align 4, !tbaa !19
  %dim.i38 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %gradient.buffer, i64 0, i32 6
  %8 = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %dim.i38, align 8, !tbaa !20
  %min.i39 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %8, i64 0, i32 0
  %9 = load i32, i32* %min.i39, align 4, !tbaa !21
  %extent.i37 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %8, i64 0, i32 1
  %10 = load i32, i32* %extent.i37, align 4, !tbaa !23
  %stride.i35 = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %8, i64 0, i32 2
  %11 = load i32, i32* %stride.i35, align 4, !tbaa !24
  %min.i = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %8, i64 1, i32 0
  %12 = load i32, i32* %min.i, align 4, !tbaa !21
  %extent.i = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %8, i64 1, i32 1
  %13 = load i32, i32* %extent.i, align 4, !tbaa !23
  %stride.i = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %8, i64 1, i32 2
  %14 = load i32, i32* %stride.i, align 4, !tbaa !24
  %cmp.i26 = icmp eq i8* %3, null
  br i1 %cmp.i26, label %_halide_buffer_is_bounds_query.exit30, label %true_bb1

_halide_buffer_is_bounds_query.exit30:            ; preds = %"assert succeeded"
  %device.i27 = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %gradient.buffer, i64 0, i32 0
  %15 = load i64, i64* %device.i27, align 8, !tbaa !25
  %cmp1.i28 = icmp eq i64 %15, 0
  br i1 %cmp1.i28, label %after_bb, label %_halide_buffer_is_bounds_query.exit

destructor_block:                                 ; preds = %"end for gradient.s0.x.loopexit.us", %"for gradient.s0.y.preheader", %_halide_buffer_is_bounds_query.exit, %"produce gradient", %"assert failed20", %"assert failed18", %"assert failed16", %"assert failed12", %"assert failed10", %"assert failed8", %"assert failed6", %"assert failed4", %"assert failed"
  %16 = phi i32 [ %2, %"assert failed" ], [ %36, %"assert failed4" ], [ %38, %"assert failed6" ], [ %40, %"assert failed8" ], [ %42, %"assert failed10" ], [ %44, %"assert failed12" ], [ %52, %"assert failed16" ], [ %54, %"assert failed18" ], [ %55, %"assert failed20" ], [ 0, %_halide_buffer_is_bounds_query.exit ], [ 0, %"produce gradient" ], [ 0, %"for gradient.s0.y.preheader" ], [ 0, %"end for gradient.s0.x.loopexit.us" ]
  ret i32 %16

after_bb:                                         ; preds = %_halide_buffer_is_bounds_query.exit30
  %17 = getelementptr inbounds [8 x i32], [8 x i32]* %0, i64 0, i64 0
  store i32 %9, i32* %17, align 4
  %18 = getelementptr inbounds [8 x i32], [8 x i32]* %0, i64 0, i64 1
  store i32 %10, i32* %18, align 4
  %19 = getelementptr inbounds [8 x i32], [8 x i32]* %0, i64 0, i64 2
  store i32 1, i32* %19, align 4
  %20 = getelementptr inbounds [8 x i32], [8 x i32]* %0, i64 0, i64 3
  store i32 0, i32* %20, align 4
  %21 = getelementptr inbounds [8 x i32], [8 x i32]* %0, i64 0, i64 4
  store i32 %12, i32* %21, align 4
  %22 = getelementptr inbounds [8 x i32], [8 x i32]* %0, i64 0, i64 5
  store i32 %13, i32* %22, align 4
  %23 = getelementptr inbounds [8 x i32], [8 x i32]* %0, i64 0, i64 6
  store i32 %10, i32* %23, align 4
  %24 = getelementptr inbounds [8 x i32], [8 x i32]* %0, i64 0, i64 7
  store i32 0, i32* %24, align 4
  store i8 0, i8* %code.i42, align 8, !tbaa !16
  %25 = bitcast %struct.halide_buffer_t* %gradient.buffer to i8*
  call void @llvm.memset.p0i8.i64(i8* %25, i8 0, i64 24, i32 8, i1 false)
  store i8 32, i8* %bits.i41, align 1, !tbaa !17
  store i16 1, i16* %lanes.i40, align 2, !tbaa !18
  store i32 2, i32* %dimensions.i, align 4, !tbaa !19
  %26 = bitcast %struct.halide_dimension_t* %8 to i8*
  %27 = bitcast [8 x i32]* %0 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %26, i8* nonnull %27, i64 16, i32 4, i1 false) #3, !tbaa.struct !26
  %.pre.i = load %struct.halide_dimension_t*, %struct.halide_dimension_t** %dim.i38, align 8, !tbaa !20
  %arrayidx.i = getelementptr inbounds [8 x i32], [8 x i32]* %0, i64 0, i64 4
  %arrayidx12.i = getelementptr inbounds %struct.halide_dimension_t, %struct.halide_dimension_t* %.pre.i, i64 1
  %28 = bitcast %struct.halide_dimension_t* %arrayidx12.i to i8*
  %29 = bitcast i32* %arrayidx.i to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull %28, i8* nonnull %29, i64 16, i32 4, i1 false) #3, !tbaa.struct !26
  %flags13.i = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %gradient.buffer, i64 0, i32 3
  store i64 0, i64* %flags13.i, align 8, !tbaa !28
  %.pre = load i8*, i8** %host.i, align 8, !tbaa !7
  %cmp.i = icmp eq i8* %.pre, null
  br i1 %cmp.i, label %_halide_buffer_is_bounds_query.exit, label %true_bb1

_halide_buffer_is_bounds_query.exit:              ; preds = %_halide_buffer_is_bounds_query.exit30, %after_bb
  %device.i = getelementptr inbounds %struct.halide_buffer_t, %struct.halide_buffer_t* %gradient.buffer, i64 0, i32 0
  %30 = load i64, i64* %device.i, align 8, !tbaa !25
  %cmp1.i = icmp eq i64 %30, 0
  br i1 %cmp1.i, label %destructor_block, label %true_bb1

true_bb1:                                         ; preds = %"assert succeeded", %after_bb, %_halide_buffer_is_bounds_query.exit
  %31 = icmp eq i8 %4, 0
  %32 = icmp eq i8 %5, 32
  %33 = and i1 %31, %32
  %34 = icmp eq i16 %6, 1
  %35 = and i1 %33, %34
  br i1 %35, label %"assert succeeded5", label %"assert failed4", !prof !29

"assert failed4":                                 ; preds = %true_bb1
  %36 = tail call i32 @halide_error_bad_type(i8* %__user_context, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str.3, i64 0, i64 0), i8 %4, i8 0, i8 %5, i8 32, i16 %6, i16 1) #3
  br label %destructor_block

"assert succeeded5":                              ; preds = %true_bb1
  %37 = icmp eq i32 %7, 2
  br i1 %37, label %"assert succeeded7", label %"assert failed6", !prof !29

"assert failed6":                                 ; preds = %"assert succeeded5"
  %38 = tail call i32 @halide_error_bad_dimensions(i8* %__user_context, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str.3, i64 0, i64 0), i32 %7, i32 2) #3
  br label %destructor_block

"assert succeeded7":                              ; preds = %"assert succeeded5"
  %39 = icmp sgt i32 %10, -1
  br i1 %39, label %"assert succeeded9", label %"assert failed8", !prof !29

"assert failed8":                                 ; preds = %"assert succeeded7"
  %40 = tail call i32 @halide_error_buffer_extents_negative(i8* %__user_context, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str.3, i64 0, i64 0), i32 0, i32 %10) #3
  br label %destructor_block

"assert succeeded9":                              ; preds = %"assert succeeded7"
  %41 = icmp sgt i32 %13, -1
  br i1 %41, label %"assert succeeded11", label %"assert failed10", !prof !29

"assert failed10":                                ; preds = %"assert succeeded9"
  %42 = tail call i32 @halide_error_buffer_extents_negative(i8* %__user_context, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str.3, i64 0, i64 0), i32 1, i32 %13) #3
  br label %destructor_block

"assert succeeded11":                             ; preds = %"assert succeeded9"
  %43 = icmp eq i32 %11, 1
  br i1 %43, label %"assert succeeded15", label %"assert failed12", !prof !29

"assert failed12":                                ; preds = %"assert succeeded11"
  %44 = tail call i32 @halide_error_constraint_violated(i8* %__user_context, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str.4, i64 0, i64 0), i32 %11, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str.5, i64 0, i64 0), i32 1) #3
  br label %destructor_block

"assert succeeded15":                             ; preds = %"assert succeeded11"
  %45 = sext i32 %13 to i64
  %46 = sext i32 %10 to i64
  %gradient.total_extent.1 = mul nsw i64 %45, %46
  %47 = sext i32 %14 to i64
  %x2 = mul nsw i64 %47, %45
  %48 = icmp sgt i64 %x2, -1
  %49 = sub nsw i64 0, %x2
  %50 = select i1 %48, i64 %x2, i64 %49
  %51 = icmp ult i64 %50, 2147483648
  br i1 %51, label %"assert succeeded17", label %"assert failed16", !prof !29

"assert failed16":                                ; preds = %"assert succeeded15"
  %52 = tail call i32 @halide_error_buffer_allocation_too_large(i8* %__user_context, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str, i64 0, i64 0), i64 %50, i64 2147483647) #3
  br label %destructor_block

"assert succeeded17":                             ; preds = %"assert succeeded15"
  %53 = icmp slt i64 %gradient.total_extent.1, 2147483648
  br i1 %53, label %"assert succeeded19", label %"assert failed18", !prof !29

"assert failed18":                                ; preds = %"assert succeeded17"
  %54 = tail call i32 @halide_error_buffer_extents_too_large(i8* %__user_context, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str, i64 0, i64 0), i64 %gradient.total_extent.1, i64 2147483647) #3
  br label %destructor_block

"assert succeeded19":                             ; preds = %"assert succeeded17"
  br i1 %cmp.i26, label %"assert failed20", label %"produce gradient", !prof !6

"assert failed20":                                ; preds = %"assert succeeded19"
  %55 = tail call i32 @halide_error_host_is_null(i8* %__user_context, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str.3, i64 0, i64 0)) #3
  br label %destructor_block

"produce gradient":                               ; preds = %"assert succeeded19"
  %56 = add nsw i32 %13, %12
  %57 = icmp sgt i32 %13, 0
  br i1 %57, label %"for gradient.s0.y.preheader", label %destructor_block, !prof !29

"for gradient.s0.y.preheader":                    ; preds = %"produce gradient"
  %58 = add nsw i32 %10, %9
  %59 = icmp sgt i32 %10, 0
  %60 = bitcast i8* %3 to i32*
  br i1 %59, label %"for gradient.s0.y.preheader.split.us", label %destructor_block, !prof !29

"for gradient.s0.y.preheader.split.us":           ; preds = %"for gradient.s0.y.preheader"
  %61 = sext i32 %9 to i64
  %62 = sext i32 %12 to i64
  %63 = add i32 %10, -1
  %64 = zext i32 %63 to i64
  %65 = add nuw nsw i64 %64, 1
  %min.iters.check = icmp ult i64 %65, 8
  %66 = and i32 %10, 7
  %n.mod.vf = zext i32 %66 to i64
  %n.vec = sub nsw i64 %65, %n.mod.vf
  %ind.end = add nsw i64 %n.vec, %61
  %.splatinsert = insertelement <2 x i64> undef, i64 %61, i32 0
  %.splat = shufflevector <2 x i64> %.splatinsert, <2 x i64> undef, <2 x i32> zeroinitializer
  %induction = add <2 x i64> %.splat, <i64 0, i64 1>
  %cmp.n = icmp eq i32 %66, 0
  br label %"for gradient.s0.y.us"

"for gradient.s0.y.us":                           ; preds = %"end for gradient.s0.x.loopexit.us", %"for gradient.s0.y.preheader.split.us"
  %indvars.iv45 = phi i64 [ %indvars.iv.next46, %"end for gradient.s0.x.loopexit.us" ], [ %62, %"for gradient.s0.y.preheader.split.us" ]
  %67 = trunc i64 %indvars.iv45 to i32
  %reass.add.us = sub i32 %67, %12
  %reass.mul.us = mul i32 %reass.add.us, %14
  %t2.us = sub i32 %reass.mul.us, %9
  %68 = sext i32 %t2.us to i64
  br i1 %min.iters.check, label %"for gradient.s0.x.us.preheader", label %vector.ph

vector.ph:                                        ; preds = %"for gradient.s0.y.us"
  %broadcast.splatinsert = insertelement <2 x i64> undef, i64 %indvars.iv45, i32 0
  %broadcast.splat = shufflevector <2 x i64> %broadcast.splatinsert, <2 x i64> undef, <2 x i32> zeroinitializer
  %broadcast.splatinsert53 = insertelement <2 x i64> undef, i64 %indvars.iv45, i32 0
  %broadcast.splat54 = shufflevector <2 x i64> %broadcast.splatinsert53, <2 x i64> undef, <2 x i32> zeroinitializer
  %broadcast.splatinsert55 = insertelement <2 x i64> undef, i64 %indvars.iv45, i32 0
  %broadcast.splat56 = shufflevector <2 x i64> %broadcast.splatinsert55, <2 x i64> undef, <2 x i32> zeroinitializer
  %broadcast.splatinsert57 = insertelement <2 x i64> undef, i64 %indvars.iv45, i32 0
  %broadcast.splat58 = shufflevector <2 x i64> %broadcast.splatinsert57, <2 x i64> undef, <2 x i32> zeroinitializer
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.ind = phi <2 x i64> [ %induction, %vector.ph ], [ %vec.ind.next, %vector.body ]
  %step.add = add <2 x i64> %vec.ind, <i64 2, i64 2>
  %step.add50 = add <2 x i64> %vec.ind, <i64 4, i64 4>
  %step.add51 = add <2 x i64> %vec.ind, <i64 6, i64 6>
  %69 = add i64 %index, %61
  %70 = add nsw <2 x i64> %vec.ind, %broadcast.splat
  %71 = add nsw <2 x i64> %step.add, %broadcast.splat54
  %72 = add nsw <2 x i64> %step.add50, %broadcast.splat56
  %73 = add nsw <2 x i64> %step.add51, %broadcast.splat58
  %74 = add nsw i64 %69, %68
  %75 = getelementptr inbounds i32, i32* %60, i64 %74
  %76 = trunc <2 x i64> %70 to <2 x i32>
  %77 = trunc <2 x i64> %71 to <2 x i32>
  %78 = trunc <2 x i64> %72 to <2 x i32>
  %79 = trunc <2 x i64> %73 to <2 x i32>
  %80 = bitcast i32* %75 to <2 x i32>*
  store <2 x i32> %76, <2 x i32>* %80, align 4, !tbaa !30
  %81 = getelementptr i32, i32* %75, i64 2
  %82 = bitcast i32* %81 to <2 x i32>*
  store <2 x i32> %77, <2 x i32>* %82, align 4, !tbaa !30
  %83 = getelementptr i32, i32* %75, i64 4
  %84 = bitcast i32* %83 to <2 x i32>*
  store <2 x i32> %78, <2 x i32>* %84, align 4, !tbaa !30
  %85 = getelementptr i32, i32* %75, i64 6
  %86 = bitcast i32* %85 to <2 x i32>*
  store <2 x i32> %79, <2 x i32>* %86, align 4, !tbaa !30
  %index.next = add i64 %index, 8
  %vec.ind.next = add <2 x i64> %vec.ind, <i64 8, i64 8>
  %87 = icmp eq i64 %index.next, %n.vec
  br i1 %87, label %middle.block, label %vector.body, !llvm.loop !33

middle.block:                                     ; preds = %vector.body
  br i1 %cmp.n, label %"end for gradient.s0.x.loopexit.us", label %"for gradient.s0.x.us.preheader"

"for gradient.s0.x.us.preheader":                 ; preds = %middle.block, %"for gradient.s0.y.us"
  %indvars.iv.ph = phi i64 [ %61, %"for gradient.s0.y.us" ], [ %ind.end, %middle.block ]
  br label %"for gradient.s0.x.us"

"for gradient.s0.x.us":                           ; preds = %"for gradient.s0.x.us.preheader", %"for gradient.s0.x.us"
  %indvars.iv = phi i64 [ %indvars.iv.next, %"for gradient.s0.x.us" ], [ %indvars.iv.ph, %"for gradient.s0.x.us.preheader" ]
  %88 = add nsw i64 %indvars.iv, %indvars.iv45
  %89 = add nsw i64 %indvars.iv, %68
  %90 = getelementptr inbounds i32, i32* %60, i64 %89
  %91 = trunc i64 %88 to i32
  store i32 %91, i32* %90, align 4, !tbaa !30
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %92 = trunc i64 %indvars.iv.next to i32
  %93 = icmp eq i32 %58, %92
  br i1 %93, label %"end for gradient.s0.x.loopexit.us", label %"for gradient.s0.x.us", !llvm.loop !35

"end for gradient.s0.x.loopexit.us":              ; preds = %"for gradient.s0.x.us", %middle.block
  %indvars.iv.next46 = add nsw i64 %indvars.iv45, 1
  %94 = trunc i64 %indvars.iv.next46 to i32
  %95 = icmp eq i32 %56, %94
  br i1 %95, label %destructor_block, label %"for gradient.s0.y.us"
}

; Function Attrs: nounwind
define i32 @gradient_argv(i8** nocapture readonly) local_unnamed_addr #3 {
entry:
  %1 = bitcast i8** %0 to i8***
  %2 = load i8**, i8*** %1, align 8
  %3 = load i8*, i8** %2, align 8
  %4 = getelementptr i8*, i8** %0, i64 1
  %5 = bitcast i8** %4 to %struct.halide_buffer_t**
  %6 = load %struct.halide_buffer_t*, %struct.halide_buffer_t** %5, align 8
  %7 = tail call i32 @gradient(i8* %3, %struct.halide_buffer_t* %6) #5
  ret i32 %7
}

; Function Attrs: norecurse nounwind readnone
define nonnull %struct.halide_filter_metadata_t* @gradient_metadata() local_unnamed_addr #4 {
entry:
  ret %struct.halide_filter_metadata_t* @gradient_metadata_storage
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #0

attributes #0 = { argmemonly nounwind }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "reciprocal-estimates"="none" }
attributes #3 = { nounwind }
attributes #4 = { norecurse nounwind readnone }
attributes #5 = { noinline }

!llvm.module.flags = !{!0, !1, !2, !3, !4}
!llvm.ident = !{!5, !5, !5, !5, !5, !5}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 2, !"halide_use_soft_float_abi", i32 0}
!2 = !{i32 2, !"halide_mcpu", !"corei7-avx"}
!3 = !{i32 2, !"halide_mattrs", !"+f16c"}
!4 = !{i32 2, !"halide_per_instruction_fast_math_flags", i32 0}
!5 = !{!"clang version 6.0.1 (branches/release_60 350052)"}
!6 = !{!"branch_weights", i32 0, i32 1073741824}
!7 = !{!8, !12, i64 16}
!8 = !{!"_ZTS15halide_buffer_t", !9, i64 0, !12, i64 8, !12, i64 16, !9, i64 24, !13, i64 32, !15, i64 36, !12, i64 40, !12, i64 48}
!9 = !{!"long long", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C++ TBAA"}
!12 = !{!"any pointer", !10, i64 0}
!13 = !{!"_ZTS13halide_type_t", !10, i64 0, !10, i64 1, !14, i64 2}
!14 = !{!"short", !10, i64 0}
!15 = !{!"int", !10, i64 0}
!16 = !{!8, !10, i64 32}
!17 = !{!8, !10, i64 33}
!18 = !{!8, !14, i64 34}
!19 = !{!8, !15, i64 36}
!20 = !{!8, !12, i64 40}
!21 = !{!22, !15, i64 0}
!22 = !{!"_ZTS18halide_dimension_t", !15, i64 0, !15, i64 4, !15, i64 8, !15, i64 12}
!23 = !{!22, !15, i64 4}
!24 = !{!22, !15, i64 8}
!25 = !{!8, !9, i64 0}
!26 = !{i64 0, i64 4, !27, i64 4, i64 4, !27, i64 8, i64 4, !27, i64 12, i64 4, !27}
!27 = !{!15, !15, i64 0}
!28 = !{!8, !9, i64 24}
!29 = !{!"branch_weights", i32 1073741824, i32 0}
!30 = !{!31, !31, i64 0}
!31 = !{!"gradient", !32, i64 0}
!32 = !{!"Halide buffer"}
!33 = distinct !{!33, !34}
!34 = !{!"llvm.loop.isvectorized", i32 1}
!35 = distinct !{!35, !36, !34}
!36 = !{!"llvm.loop.unroll.runtime.disable"}
Creating new execution engine
Target triple: x86_64--linux-gnu
JIT compiling shared runtime for x86-64-linux-avx-f16c-jit-sse41-user_context
JIT Compiling halide_buffer_copy
Function halide_buffer_copy is at 0x7fea863eef30
JIT Compiling halide_buffer_copy_already_locked
Function halide_buffer_copy_already_locked is at 0x7fea863ed150
JIT Compiling halide_buffer_to_string
Function halide_buffer_to_string is at 0x7fea863ed420
JIT Compiling halide_cache_cleanup
Function halide_cache_cleanup is at 0x7fea863eefd0
JIT Compiling halide_cond_broadcast
Function halide_cond_broadcast is at 0x7fea863ed650
JIT Compiling halide_cond_signal
Function halide_cond_signal is at 0x7fea863ed6c0
JIT Compiling halide_cond_wait
Function halide_cond_wait is at 0x7fea863ed730
JIT Compiling halide_copy_to_device
Function halide_copy_to_device is at 0x7fea863ed8b0
JIT Compiling halide_copy_to_device_legacy
Function halide_copy_to_device_legacy is at 0x7fea863ed910
JIT Compiling halide_copy_to_host
Function halide_copy_to_host is at 0x7fea863eda10
JIT Compiling halide_copy_to_host_legacy
Function halide_copy_to_host_legacy is at 0x7fea863edaf0
JIT Compiling halide_create_temp_file
Function halide_create_temp_file is at 0x7fea863edbe0
JIT Compiling halide_current_time_ns
Function halide_current_time_ns is at 0x7fea863edd20
JIT Compiling halide_debug_to_file
Function halide_debug_to_file is at 0x7fea863ec000
JIT Compiling halide_default_buffer_copy
Function halide_default_buffer_copy is at 0x7fea863edd70
JIT Compiling halide_default_device_and_host_free
Function halide_default_device_and_host_free is at 0x7fea863edd80
JIT Compiling halide_default_device_and_host_malloc
Function halide_default_device_and_host_malloc is at 0x7fea863ecd70
JIT Compiling halide_default_device_crop
Function halide_default_device_crop is at 0x7fea863ede60
JIT Compiling halide_default_device_detach_native
Function halide_default_device_detach_native is at 0x7fea863ede90
JIT Compiling halide_default_device_release_crop
Function halide_default_device_release_crop is at 0x7fea863edf50
JIT Compiling halide_default_device_slice
Function halide_default_device_slice is at 0x7fea863edf80
JIT Compiling halide_default_device_wrap_native
Function halide_default_device_wrap_native is at 0x7fea863ecf30
JIT Compiling halide_default_do_loop_task
Function halide_default_do_loop_task is at 0x7fea863edfb0
JIT Compiling halide_default_do_par_for
Function halide_default_do_par_for is at 0x7fea863eb000
JIT Compiling halide_default_do_parallel_tasks
Function halide_default_do_parallel_tasks is at 0x7fea863eb0e0
JIT Compiling halide_default_do_task
Function halide_default_do_task is at 0x7fea863edfd0
JIT Compiling halide_default_error
Function halide_default_error is at 0x7fea863eb220
JIT Compiling halide_default_free
Function halide_default_free is at 0x7fea863eb2d0
JIT Compiling halide_default_get_library_symbol
Function halide_default_get_library_symbol is at 0x7fea863eb2f0
JIT Compiling halide_default_get_symbol
Function halide_default_get_symbol is at 0x7fea863eb310
JIT Compiling halide_default_load_library
Function halide_default_load_library is at 0x7fea863eb330
JIT Compiling halide_default_malloc
Function halide_default_malloc is at 0x7fea863eb370
JIT Compiling halide_default_print
Function halide_default_print is at 0x7fea863eb3c0
JIT Compiling halide_default_semaphore_init
Function halide_default_semaphore_init is at 0x7fea863edfe0
JIT Compiling halide_default_semaphore_release
Function halide_default_semaphore_release is at 0x7fea863eb400
JIT Compiling halide_default_semaphore_try_acquire
Function halide_default_semaphore_try_acquire is at 0x7fea863eb470
JIT Compiling halide_default_trace
Function halide_default_trace is at 0x7fea863eb4a0
JIT Compiling halide_device_and_host_free
Function halide_device_and_host_free is at 0x7fea863ea000
JIT Compiling halide_device_and_host_free_as_destructor
Function halide_device_and_host_free_as_destructor is at 0x7fea863ebf50
JIT Compiling halide_device_and_host_malloc
Function halide_device_and_host_malloc is at 0x7fea863ea150
JIT Compiling halide_device_crop
Function halide_device_crop is at 0x7fea863ea280
JIT Compiling halide_device_detach_native
Function halide_device_detach_native is at 0x7fea863ea340
JIT Compiling halide_device_free
Function halide_device_free is at 0x7fea863ea460
JIT Compiling halide_device_free_as_destructor
Function halide_device_free_as_destructor is at 0x7fea863ebf70
JIT Compiling halide_device_free_legacy
Function halide_device_free_legacy is at 0x7fea863ea580
JIT Compiling halide_device_host_nop_free
Function halide_device_host_nop_free is at 0x7fea863ecfe0
JIT Compiling halide_device_malloc
Function halide_device_malloc is at 0x7fea863ea670
JIT Compiling halide_device_malloc_legacy
Function halide_device_malloc_legacy is at 0x7fea863ea780
JIT Compiling halide_device_release
Function halide_device_release is at 0x7fea863ebf90
JIT Compiling halide_device_release_crop
Function halide_device_release_crop is at 0x7fea863ea880
JIT Compiling halide_device_slice
Function halide_device_slice is at 0x7fea863ea900
JIT Compiling halide_device_sync
Function halide_device_sync is at 0x7fea863ea9d0
JIT Compiling halide_device_sync_legacy
Function halide_device_sync_legacy is at 0x7fea863eaab0
JIT Compiling halide_device_wrap_native
Function halide_device_wrap_native is at 0x7fea863eaba0
JIT Compiling halide_do_loop_task
Function halide_do_loop_task is at 0x7fea863ebfa0
JIT Compiling halide_do_par_for
Function halide_do_par_for is at 0x7fea863ebfc0
JIT Compiling halide_do_parallel_tasks
Function halide_do_parallel_tasks is at 0x7fea863eacc0
JIT Compiling halide_do_task
Function halide_do_task is at 0x7fea863eace0
JIT Compiling halide_double_to_string
Function halide_double_to_string is at 0x7fea863e9000
JIT Compiling halide_downgrade_buffer_t
Function halide_downgrade_buffer_t is at 0x7fea863ead00
JIT Compiling halide_downgrade_buffer_t_device_fields
Function halide_downgrade_buffer_t_device_fields is at 0x7fea863eadd0
JIT Compiling halide_error
Function halide_error is at 0x7fea863eae60
JIT Compiling halide_error_access_out_of_bounds
Function halide_error_access_out_of_bounds is at 0x7fea863e9530
JIT Compiling halide_error_bad_dimensions
Function halide_error_bad_dimensions is at 0x7fea863eae80
JIT Compiling halide_error_bad_extern_fold
Function halide_error_bad_extern_fold is at 0x7fea863e9840
JIT Compiling halide_error_bad_fold
Function halide_error_bad_fold is at 0x7fea863e9c30
JIT Compiling halide_error_bad_type
Function halide_error_bad_type is at 0x7fea863e9db0
JIT Compiling halide_error_bounds_inference_call_failed
Function halide_error_bounds_inference_call_failed is at 0x7fea863e8000
JIT Compiling halide_error_buffer_allocation_too_large
Function halide_error_buffer_allocation_too_large is at 0x7fea863e8130
JIT Compiling halide_error_buffer_argument_is_null
Function halide_error_buffer_argument_is_null is at 0x7fea863e8290
JIT Compiling halide_error_buffer_extents_negative
Function halide_error_buffer_extents_negative is at 0x7fea863e83a0
JIT Compiling halide_error_buffer_extents_too_large
Function halide_error_buffer_extents_too_large is at 0x7fea863e8510
JIT Compiling halide_error_buffer_is_null
Function halide_error_buffer_is_null is at 0x7fea863e8670
JIT Compiling halide_error_constraint_violated
Function halide_error_constraint_violated is at 0x7fea863e8780
JIT Compiling halide_error_constraints_make_required_region_smaller
Function halide_error_constraints_make_required_region_smaller is at 0x7fea863e8920
JIT Compiling halide_error_debug_to_file_failed
Function halide_error_debug_to_file_failed is at 0x7fea863e8b20
JIT Compiling halide_error_device_interface_no_device
Function halide_error_device_interface_no_device is at 0x7fea863e9f20
JIT Compiling halide_error_explicit_bounds_too_small
Function halide_error_explicit_bounds_too_small is at 0x7fea863e8c80
JIT Compiling halide_error_extern_stage_failed
Function halide_error_extern_stage_failed is at 0x7fea863e8e70
JIT Compiling halide_error_failed_to_downgrade_buffer_t
Function halide_error_failed_to_downgrade_buffer_t is at 0x7fea863e7000
JIT Compiling halide_error_failed_to_upgrade_buffer_t
Function halide_error_failed_to_upgrade_buffer_t is at 0x7fea863e7130
JIT Compiling halide_error_fold_factor_too_small
Function halide_error_fold_factor_too_small is at 0x7fea863e7260
JIT Compiling halide_error_host_and_device_dirty
Function halide_error_host_and_device_dirty is at 0x7fea863e7440
JIT Compiling halide_error_host_is_null
Function halide_error_host_is_null is at 0x7fea863e7510
JIT Compiling halide_error_integer_division_by_zero
Function halide_error_integer_division_by_zero is at 0x7fea863e7620
JIT Compiling halide_error_no_device_interface
Function halide_error_no_device_interface is at 0x7fea863e76f0
JIT Compiling halide_error_out_of_memory
Function halide_error_out_of_memory is at 0x7fea863e8fa0
JIT Compiling halide_error_param_too_large_f64
Function halide_error_param_too_large_f64 is at 0x7fea863e77c0
JIT Compiling halide_error_param_too_large_i64
Function halide_error_param_too_large_i64 is at 0x7fea863e7920
JIT Compiling halide_error_param_too_large_u64
Function halide_error_param_too_large_u64 is at 0x7fea863e7a80
JIT Compiling halide_error_param_too_small_f64
Function halide_error_param_too_small_f64 is at 0x7fea863e7be0
JIT Compiling halide_error_param_too_small_i64
Function halide_error_param_too_small_i64 is at 0x7fea863e7d40
JIT Compiling halide_error_param_too_small_u64
Function halide_error_param_too_small_u64 is at 0x7fea863e6000
JIT Compiling halide_error_requirement_failed
Function halide_error_requirement_failed is at 0x7fea863e7ea0
JIT Compiling halide_error_specialize_fail
Function halide_error_specialize_fail is at 0x7fea863e6160
JIT Compiling halide_error_unaligned_host_ptr
Function halide_error_unaligned_host_ptr is at 0x7fea863e6260
JIT Compiling halide_float16_bits_to_double
Function halide_float16_bits_to_double is at 0x7fea863e8fd0
JIT Compiling halide_float16_bits_to_float
Function halide_float16_bits_to_float is at 0x7fea863e63a0
JIT Compiling halide_free
Function halide_free is at 0x7fea863e7fd0
JIT Compiling halide_get_gpu_device
Function halide_get_gpu_device is at 0x7fea863e6410
JIT Compiling halide_get_library_symbol
Function halide_get_library_symbol is at 0x7fea863e64b0
JIT Compiling halide_get_symbol
Function halide_get_symbol is at 0x7fea863e64d0
JIT Compiling halide_get_trace_file
Function halide_get_trace_file is at 0x7fea863e64f0
JIT Compiling halide_host_cpu_count
Function halide_host_cpu_count is at 0x7fea863e6610
JIT Compiling halide_int64_to_string
Function halide_int64_to_string is at 0x7fea863e6630
JIT Compiling halide_join_thread
Function halide_join_thread is at 0x7fea863e6660
JIT Compiling halide_load_library
Function halide_load_library is at 0x7fea863e66a0
JIT Compiling halide_malloc
Function halide_malloc is at 0x7fea863e66c0
JIT Compiling halide_memoization_cache_cleanup
Function halide_memoization_cache_cleanup is at 0x7fea863e66e0
JIT Compiling halide_memoization_cache_lookup
Function halide_memoization_cache_lookup is at 0x7fea863e67a0
JIT Compiling halide_memoization_cache_release
Function halide_memoization_cache_release is at 0x7fea863e6ca0
JIT Compiling halide_memoization_cache_set_size
Function halide_memoization_cache_set_size is at 0x7fea863e6d40
JIT Compiling halide_memoization_cache_store
Function halide_memoization_cache_store is at 0x7fea863e5000
JIT Compiling halide_msan_annotate_buffer_is_initialized
Function halide_msan_annotate_buffer_is_initialized is at 0x7fea863ebfe0
JIT Compiling halide_msan_annotate_buffer_is_initialized_as_destructor
Function halide_msan_annotate_buffer_is_initialized_as_destructor is at 0x7fea863e6da0
JIT Compiling halide_msan_annotate_memory_is_initialized
Function halide_msan_annotate_memory_is_initialized is at 0x7fea863e6db0
JIT Compiling halide_mutex_lock
Function halide_mutex_lock is at 0x7fea863e6dc0
JIT Compiling halide_mutex_unlock
Function halide_mutex_unlock is at 0x7fea863e6ed0
JIT Compiling halide_pointer_to_string
Function halide_pointer_to_string is at 0x7fea863e6f50
JIT Compiling halide_print
Function halide_print is at 0x7fea863e6fc0
JIT Compiling halide_profiler_get_pipeline_state
Function halide_profiler_get_pipeline_state is at 0x7fea863e54b0
JIT Compiling halide_profiler_get_state
Function halide_profiler_get_state is at 0x7fea863e6fe0
JIT Compiling halide_profiler_memory_allocate
Function halide_profiler_memory_allocate is at 0x7fea863e5520
JIT Compiling halide_profiler_memory_free
Function halide_profiler_memory_free is at 0x7fea863e5680
JIT Compiling halide_profiler_pipeline_end
Function halide_profiler_pipeline_end is at 0x7fea863e5750
JIT Compiling halide_profiler_pipeline_start
Function halide_profiler_pipeline_start is at 0x7fea863e5760
JIT Compiling halide_profiler_report
Function halide_profiler_report is at 0x7fea863e5820
JIT Compiling halide_profiler_report_unlocked
Function halide_profiler_report_unlocked is at 0x7fea863e4000
JIT Compiling halide_profiler_reset
Function halide_profiler_reset is at 0x7fea863e5870
JIT Compiling halide_profiler_reset_unlocked
Function halide_profiler_reset_unlocked is at 0x7fea863e58c0
JIT Compiling halide_profiler_shutdown
Function halide_profiler_shutdown is at 0x7fea863e5920
JIT Compiling halide_profiler_stack_peak_update
Function halide_profiler_stack_peak_update is at 0x7fea863e5990
JIT Compiling halide_semaphore_init
Function halide_semaphore_init is at 0x7fea863e5a40
JIT Compiling halide_semaphore_release
Function halide_semaphore_release is at 0x7fea863e5a60
JIT Compiling halide_semaphore_try_acquire
Function halide_semaphore_try_acquire is at 0x7fea863e5a80
JIT Compiling halide_set_custom_do_loop_task
Function halide_set_custom_do_loop_task is at 0x7fea863e5aa0
JIT Compiling halide_set_custom_do_par_for
Function halide_set_custom_do_par_for is at 0x7fea863e5ac0
JIT Compiling halide_set_custom_do_task
Function halide_set_custom_do_task is at 0x7fea863e5ae0
JIT Compiling halide_set_custom_free
Function halide_set_custom_free is at 0x7fea863e5b00
JIT Compiling halide_set_custom_get_library_symbol
Function halide_set_custom_get_library_symbol is at 0x7fea863e5b20
JIT Compiling halide_set_custom_get_symbol
Function halide_set_custom_get_symbol is at 0x7fea863e5b40
JIT Compiling halide_set_custom_load_library
Function halide_set_custom_load_library is at 0x7fea863e5b60
JIT Compiling halide_set_custom_malloc
Function halide_set_custom_malloc is at 0x7fea863e5b80
JIT Compiling halide_set_custom_parallel_runtime
Function halide_set_custom_parallel_runtime is at 0x7fea863e5ba0
JIT Compiling halide_set_custom_print
Function halide_set_custom_print is at 0x7fea863e5c10
JIT Compiling halide_set_custom_trace
Function halide_set_custom_trace is at 0x7fea863e5c30
JIT Compiling halide_set_error_handler
Function halide_set_error_handler is at 0x7fea863e5c50
JIT Compiling halide_set_gpu_device
Function halide_set_gpu_device is at 0x7fea863e5c70
JIT Compiling halide_set_num_threads
Function halide_set_num_threads is at 0x7fea863e5c90
JIT Compiling halide_set_trace_file
Function halide_set_trace_file is at 0x7fea863e5d40
JIT Compiling halide_shutdown_thread_pool
Function halide_shutdown_thread_pool is at 0x7fea863e5d60
JIT Compiling halide_shutdown_trace
Function halide_shutdown_trace is at 0x7fea863e5e30
JIT Compiling halide_sleep_ms
Function halide_sleep_ms is at 0x7fea863e5eb0
JIT Compiling halide_spawn_thread
Function halide_spawn_thread is at 0x7fea863e5ed0
JIT Compiling halide_start_clock
Function halide_start_clock is at 0x7fea863e5f30
JIT Compiling halide_string_to_string
Function halide_string_to_string is at 0x7fea863e5f70
JIT Compiling halide_thread_pool_cleanup
Function halide_thread_pool_cleanup is at 0x7fea863e5fb0
JIT Compiling halide_trace
Function halide_trace is at 0x7fea863e5fd0
JIT Compiling halide_trace_cleanup
Function halide_trace_cleanup is at 0x7fea863e4970
JIT Compiling halide_trace_helper
Function halide_trace_helper is at 0x7fea863e4990
JIT Compiling halide_type_to_string
Function halide_type_to_string is at 0x7fea863e4a60
JIT Compiling halide_uint64_to_string
Function halide_uint64_to_string is at 0x7fea863e4b30
JIT Compiling halide_upgrade_buffer_t
Function halide_upgrade_buffer_t is at 0x7fea863e4bb0
Finalizing object
Creating new execution engine
Target triple: x86_64--linux-gnu
JIT compiling gradient for x86-64-linux-avx-f16c-jit-sse41-user_context
JIT Compiling gradient
Function gradient is at 0x7fea863d8000
JIT Compiling gradient_argv
Function gradient_argv is at 0x7fea863d8410
Finalizing object
custom_print: 0x7fea863eb3c0
custom_malloc: 0x7fea863eb370
custom_free: 0x7fea863eb2d0
custom_do_task: 0x7fea863edfd0
custom_do_par_for: 0x7fea863eb000
custom_error: 0x7fea817951da
custom_trace: 0x7fea863eb4a0
__user_context @ 0x7ffc9cef33c8
JIT output buffer @ 0x1b8ff98, 0x1b8fe00
Calling jitted function
Back from jitted function. Exit status was 0
Creating initial loop nests...
Injecting realization of { gradient }
for (.__root, 0, 1) {
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    let gradient.s0.__outermost.loop_extent = 1
    let gradient.s0.__outermost.loop_max = 0
    let gradient.s0.__outermost.loop_min = 0
    for (gradient.s0.__outermost, gradient.s0.__outermost.loop_min, gradient.s0.__outermost.loop_extent) {
      for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
        for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
          gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
        }
      }
    }
  }
}

Lowering after creating initial loop nests:
produce gradient {
  let gradient.s0.y.loop_max = gradient.s0.y.max
  let gradient.s0.y.loop_min = gradient.s0.y.min
  let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
  let gradient.s0.x.loop_max = gradient.s0.x.max
  let gradient.s0.x.loop_min = gradient.s0.x.min
  let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
  for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
    for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
      gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
    }
  }
}

Skipping injecting memoization...
Injecting tracing...
Lowering after injecting tracing:
produce gradient {
  let gradient.s0.y.loop_max = gradient.s0.y.max
  let gradient.s0.y.loop_min = gradient.s0.y.min
  let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
  let gradient.s0.x.loop_max = gradient.s0.x.max
  let gradient.s0.x.loop_min = gradient.s0.x.min
  let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
  for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
    for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
      gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
    }
  }
}

Adding checks for parameters
Lowering after injecting parameter checks:
produce gradient {
  let gradient.s0.y.loop_max = gradient.s0.y.max
  let gradient.s0.y.loop_min = gradient.s0.y.min
  let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
  let gradient.s0.x.loop_max = gradient.s0.x.max
  let gradient.s0.x.loop_min = gradient.s0.x.min
  let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
  for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
    for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
      gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
    }
  }
}

Computing bounds of each function's value
Bounds on value 0 for func gradient are: neg_inf, pos_inf
Adding checks for images
Injecting constraints for gradient.0
Injecting constraints for gradient.1
Lowering after injecting image checks:
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Performing computation bounds inference...
Lowering after computation bounds inference:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Removing extern loops...
Lowering after removing extern loops:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Performing sliding window optimization...
Lowering after sliding window:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Performing allocation bounds inference...
Lowering after allocation bounds inference:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Removing code that depends on undef values...
Lowering after removing code that depends on undef values:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Uniquifying variable names...
Lowering after uniquifying variable names:
let gradient.s0.y.max = ((gradient.min.1 + gradient.extent.1) - 1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.min.0 + gradient.extent.0) - 1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
let gradient.min.0.required = gradient.s0.x.min
let gradient.stride.0.required = 1
let gradient.extent.1.required = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
let gradient.min.1.required = gradient.s0.y.min
let gradient.stride.1.required = (gradient.stride.0.required*gradient.extent.0.required)
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0.required
let gradient.extent.0.proposed = gradient.extent.0.required
let gradient.stride.1.proposed = gradient.stride.1.required
let gradient.min.1.proposed = gradient.min.1.required
let gradient.extent.1.proposed = gradient.extent.1.required
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.0.proposed <= gradient.min.0.required) && (((gradient.min.0.proposed + gradient.extent.0.proposed) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 0, gradient.min.0.proposed, ((gradient.min.0.proposed + gradient.extent.0.proposed) - 1), gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1)))
assert((!_halide_buffer_is_bounds_query(gradient.buffer) || ((gradient.min.1.proposed <= gradient.min.1.required) && (((gradient.min.1.proposed + gradient.extent.1.proposed) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1)))), halide_error_constraints_make_required_region_smaller("Output buffer gradient", 1, gradient.min.1.proposed, ((gradient.min.1.proposed + gradient.extent.1.proposed) - 1), gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1)))
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0.proposed, gradient.extent.0.proposed, gradient.stride.0.proposed, 0, gradient.min.1.proposed, gradient.extent.1.proposed, gradient.stride.1.proposed, 0), (uint64)0)
}
if (!((uint1)0 || _halide_buffer_is_bounds_query(gradient.buffer))) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert(((gradient.min.0 <= gradient.min.0.required) && (((gradient.min.0 + gradient.extent.0) - 1) >= ((gradient.min.0.required + gradient.extent.0.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 0, gradient.min.0.required, ((gradient.min.0.required + gradient.extent.0.required) - 1), gradient.min.0, ((gradient.min.0 + gradient.extent.0) - 1)))
  assert((gradient.extent.0 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert(((gradient.min.1 <= gradient.min.1.required) && (((gradient.min.1 + gradient.extent.1) - 1) >= ((gradient.min.1.required + gradient.extent.1.required) - 1))), halide_error_access_out_of_bounds("Output buffer gradient", 1, gradient.min.1.required, ((gradient.min.1.required + gradient.extent.1.required) - 1), gradient.min.1, ((gradient.min.1 + gradient.extent.1) - 1)))
  assert((gradient.extent.1 >= 0), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == gradient.stride.0.constrained), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", gradient.stride.0.constrained))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*gradient.total_extent.0)
  assert((abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.0)*int64(gradient.stride.0.constrained))), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = gradient.s0.y.max
    let gradient.s0.y.loop_min = gradient.s0.y.min
    let gradient.s0.y.loop_extent = ((gradient.s0.y.max + 1) - gradient.s0.y.min)
    let gradient.s0.x.loop_max = gradient.s0.x.max
    let gradient.s0.x.loop_min = gradient.s0.x.min
    let gradient.s0.x.loop_extent = ((gradient.s0.x.max + 1) - gradient.s0.x.min)
    for (gradient.s0.y, gradient.s0.y.loop_min, gradient.s0.y.loop_extent) {
      for (gradient.s0.x, gradient.s0.x.loop_min, gradient.s0.x.loop_extent) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Simplifying...
Lowering after first simplification:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
    let gradient.s0.y.loop_min = gradient.min.1
    let gradient.s0.y.loop_extent = gradient.extent.1
    let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
    let gradient.s0.x.loop_min = gradient.min.0
    let gradient.s0.x.loop_extent = gradient.extent.0
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Performing storage folding optimization...
Lowering after storage folding:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
    let gradient.s0.y.loop_min = gradient.min.1
    let gradient.s0.y.loop_extent = gradient.extent.1
    let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
    let gradient.s0.x.loop_min = gradient.min.0
    let gradient.s0.x.loop_extent = gradient.extent.0
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Injecting debug_to_file calls...
Lowering after injecting debug_to_file calls:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
    let gradient.s0.y.loop_min = gradient.min.1
    let gradient.s0.y.loop_extent = gradient.extent.1
    let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
    let gradient.s0.x.loop_min = gradient.min.0
    let gradient.s0.x.loop_extent = gradient.extent.0
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Injecting prefetches...
Lowering after injecting prefetches:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
    let gradient.s0.y.loop_min = gradient.min.1
    let gradient.s0.y.loop_extent = gradient.extent.1
    let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
    let gradient.s0.x.loop_min = gradient.min.0
    let gradient.s0.x.loop_extent = gradient.extent.0
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Dynamically skipping stages...
Lowering after dynamically skipping stages:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
    let gradient.s0.y.loop_min = gradient.min.1
    let gradient.s0.y.loop_extent = gradient.extent.1
    let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
    let gradient.s0.x.loop_min = gradient.min.0
    let gradient.s0.x.loop_extent = gradient.extent.0
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Forking asynchronous producers...
Lowering after forking asynchronous producers:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
  let gradient.s0.y.loop_min = gradient.min.1
  let gradient.s0.y.loop_extent = gradient.extent.1
  let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
  let gradient.s0.x.loop_min = gradient.min.0
  let gradient.s0.x.loop_extent = gradient.extent.0
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Destructuring tuple-valued realizations...
Lowering after destructuring tuple-valued realizations:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
  let gradient.s0.y.loop_min = gradient.min.1
  let gradient.s0.y.loop_extent = gradient.extent.1
  let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
  let gradient.s0.x.loop_min = gradient.min.0
  let gradient.s0.x.loop_extent = gradient.extent.0
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Canonicalizing GPU var names...
Lowering after canonicalizing GPU var names:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
  let gradient.s0.y.loop_min = gradient.min.1
  let gradient.s0.y.loop_extent = gradient.extent.1
  let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
  let gradient.s0.x.loop_min = gradient.min.0
  let gradient.s0.x.loop_extent = gradient.extent.0
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient(gradient.s0.x, gradient.s0.y) = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Performing storage flattening...
Lowering after storage flattening:
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
  let gradient.s0.y.loop_min = gradient.min.1
  let gradient.s0.y.loop_extent = gradient.extent.1
  let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
  let gradient.s0.x.loop_min = gradient.min.0
  let gradient.s0.x.loop_extent = gradient.extent.0
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((0 + (gradient.s0.x*gradient.stride.0)) + (gradient.s0.y*gradient.stride.1)) - ((0 + (gradient.min.0*gradient.stride.0)) + (gradient.min.1*gradient.stride.1)))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Unpacking buffer arguments...
Lowering after unpacking buffer arguments...
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
let gradient.s0.y.max = ((gradient.extent.1 + gradient.min.1) + -1)
let gradient.s0.y.min = gradient.min.1
let gradient.s0.x.max = ((gradient.extent.0 + gradient.min.0) + -1)
let gradient.s0.x.min = gradient.min.0
let gradient.extent.0.required = gradient.extent.0
let gradient.min.0.required = gradient.min.0
let gradient.stride.0.required = 1
let gradient.extent.1.required = gradient.extent.1
let gradient.min.1.required = gradient.min.1
let gradient.stride.1.required = gradient.extent.0
let gradient.stride.0.constrained = 1
let gradient.stride.0.proposed = 1
let gradient.min.0.proposed = gradient.min.0
let gradient.extent.0.proposed = gradient.extent.0
let gradient.stride.1.proposed = gradient.extent.0
let gradient.min.1.proposed = gradient.min.1
let gradient.extent.1.proposed = gradient.extent.1
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.0 = int64(gradient.extent.0)
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  let gradient.s0.y.loop_max = ((gradient.extent.1 + gradient.min.1) + -1)
  let gradient.s0.y.loop_min = gradient.min.1
  let gradient.s0.y.loop_extent = gradient.extent.1
  let gradient.s0.x.loop_max = ((gradient.extent.0 + gradient.min.0) + -1)
  let gradient.s0.x.loop_min = gradient.min.0
  let gradient.s0.x.loop_extent = gradient.extent.0
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((0 + (gradient.s0.x*gradient.stride.0)) + (gradient.s0.y*gradient.stride.1)) - ((0 + (gradient.min.0*gradient.stride.0)) + (gradient.min.1*gradient.stride.1)))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Skipping rewriting memoized allocations...
Simplifying...
Lowering after second simplifcation:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Reduce prefetch dimension...
Lowering after reduce prefetch dimension:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}

Unrolling...
Lowering after unrolling:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Vectorizing...
Lowering after vectorizing:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Detecting vector interleavings...
Lowering after rewriting vector interleavings:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Partitioning loops to simplify boundary conditions...
Lowering after partitioning loops:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Trimming loops to the region over which they do something...
Lowering after loop trimming:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Injecting early frees...
Lowering after injecting early frees:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Bounding small allocations...
Lowering after bounding small allocations:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Simplifying...
Lowering unsafe promises...
Lowering after lowering unsafe promises:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(((gradient.s0.y*gradient.stride.1) + gradient.s0.x) - ((gradient.min.1*gradient.stride.1) + gradient.min.0))] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Lowering after final simplification:
assert((reinterpret(uint64, gradient.buffer) != (uint64)0), halide_error_buffer_argument_is_null("gradient"))
let gradient = _halide_buffer_get_host(gradient.buffer)
let gradient.type.code = _halide_buffer_get_type_code(gradient.buffer)
let gradient.type.bits = _halide_buffer_get_type_bits(gradient.buffer)
let gradient.type.lanes = _halide_buffer_get_type_lanes(gradient.buffer)
let gradient.dimensions = _halide_buffer_get_dimensions(gradient.buffer)
let gradient.min.0 = _halide_buffer_get_min(gradient.buffer, 0)
let gradient.extent.0 = _halide_buffer_get_extent(gradient.buffer, 0)
let gradient.stride.0 = _halide_buffer_get_stride(gradient.buffer, 0)
let gradient.min.1 = _halide_buffer_get_min(gradient.buffer, 1)
let gradient.extent.1 = _halide_buffer_get_extent(gradient.buffer, 1)
let gradient.stride.1 = _halide_buffer_get_stride(gradient.buffer, 1)
if (_halide_buffer_is_bounds_query(gradient.buffer)) {
  _halide_buffer_init(gradient.buffer, _halide_buffer_get_shape(gradient.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), gradient.min.0, gradient.extent.0, 1, 0, gradient.min.1, gradient.extent.1, gradient.extent.0, 0), (uint64)0)
}
if (!_halide_buffer_is_bounds_query(gradient.buffer)) {
  assert((((gradient.type.code == (uint8)0) && (gradient.type.bits == (uint8)32)) && (gradient.type.lanes == (uint16)1)), halide_error_bad_type("Output buffer gradient", gradient.type.code, (uint8)0, gradient.type.bits, (uint8)32, gradient.type.lanes, (uint16)1))
  assert((gradient.dimensions == 2), halide_error_bad_dimensions("Output buffer gradient", gradient.dimensions, 2))
  assert((0 <= gradient.extent.0), halide_error_buffer_extents_negative("Output buffer gradient", 0, gradient.extent.0))
  assert((0 <= gradient.extent.1), halide_error_buffer_extents_negative("Output buffer gradient", 1, gradient.extent.1))
  assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
  let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
  assert((abs(int64(gradient.extent.0)) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs(int64(gradient.extent.0)), (uint64)2147483647))
  assert((abs((int64(gradient.extent.1)*int64(gradient.stride.1))) <= (uint64)2147483647), halide_error_buffer_allocation_too_large("gradient", abs((int64(gradient.extent.1)*int64(gradient.stride.1))), (uint64)2147483647))
  assert((gradient.total_extent.1 <= (int64)2147483647), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, (int64)2147483647))
  assert((gradient != reinterpret((void *), (uint64)0)), halide_error_host_is_null("Output buffer gradient"))
  produce gradient {
    let t4 = ((gradient.min.1*gradient.stride.1) + gradient.min.0)
    for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
      let t5 = ((gradient.s0.y*gradient.stride.1) - t4)
      for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
        gradient[(gradient.s0.x + t5)] = (gradient.s0.x + gradient.s0.y)
      }
    }
  }
}


Skipping Hexagon offload...
Module.compile(): stmt_html_name gradient.html
Success 

